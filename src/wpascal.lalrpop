use crate::{
    ast, lexer,
    symbol::Symbol, 
    parser::ParseContext as Context,
};

grammar<'a>(ctxt: &'a mut Context);

pub TopLevel: ast::TopLevel = {
    <start:@L> <items:Items> <end:@R> => ast::TopLevel {
        items,
        span: (start..end),
        diagnostics: ctxt.diagnostics,
        node_id: ctxt.make_node_id(),
    }
};

Items: Vec<ast::Item> = {
    => vec![],
    <mut items:Items> <next:Item> => {
        items.push(next);
        items
    }
};

Item: ast::Item = {
    GlobalDef,
    StructDef,
    FunctionDef,
};

GlobalDef: ast::Item = {
    <sloc:@L> <is_const:"const"?> <ty:TypeExpr> <ident:Ident> <init:("=" <Expression>)?> ";" <eloc:@R> => ast::Item {
        ident,
        kind: ast::ItemKind::GlobalVar(Box::new(ty), init.map(|b| Box::new(b)), is_const.is_some()),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

StructDef: ast::Item = {
    <sloc:@L> "struct" <ident:Ident> <generics:("<" <GenericParams> ">")?> "{" <f:StructField*> "}" <eloc:@R> => {
        let stc = ast::Struct {
            generics: generics.unwrap_or(Vec::new()),
            fields: f,
            attributes: vec![]
        };
        ast::Item {
            ident,
            kind: ast::ItemKind::Struct(Box::new(stc)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

StructField: ast::FieldDef = {
    <sloc:@L> <ty:TypeExpr> <name:Ident> ";" <eloc:@R> => ast::FieldDef {
        name, ty, span: (sloc..eloc), node_id: ctxt.make_node_id(),
    }
};

FunctionDef: ast::Item = {
    <sloc:@L> <ret_ty:TypeExpr> <ident:Ident> <generics:("<" <GenericParams> ">")?> 
    <p:Parameters> <body:Body> <eloc:@R> => {
        let func = ast::Function {
            params: p.unwrap_or(Vec::new()),
            returns: ret_ty,
            generics: generics.unwrap_or(Vec::new()),
            span: (sloc..eloc),
            body,
            attributes: vec![]
        };
        ast::Item {
            ident,
            kind: ast::ItemKind::Function(Box::new(func)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
};

Body: Option<Vec<ast::Stmt>> = {
    "{" <Statement*> "}" => Some(<>),
    ";" => None,
};

Parameters: Option<Vec<ast::Param>> = {
    "(" <p:OneOrMore<Paramter, ",">?> ")" => p
};

Paramter: ast::Param = {
    <sloc:@L> <ty:TypeExpr> <pat:Pat> <eloc:@R>  => {
        ast::Param {
            pat,
            ty,
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

Statement: ast::Stmt = {
    LocalStatement,
    IfStatement,
    WhileStatement,
    ForStatement,
    ControlFlowStmt,
    ExpressionStmt,
    ReturnStmt,
    ! =>? ast::handle_stmt_error(<>, ctxt.diagnostics)
};

LocalStatement: ast::Stmt = {
    <sloc:@L> "var" <pat:Pat> <init:("=" <Expression>)?> ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::Local(pat, None, init.map(|e| Box::new(e))),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <mut ty:SimpleTypeExpr> <name:Ident> <array_cap:("[" <ArrayCap> "]" <@R>)?> <init:("=" <Expression>)?> ";" <eloc:@R> => {
        let pat = ast::Pattern {
            span: name.span.clone(),
            kind: ast::PatternKind::Ident(name),
            node_id: ctxt.make_node_id(),
        };
        if let Some((array_cap, end)) = array_cap {
            ty = ast::TypeExpr {
                kind: ast::TypeExprKind::Array(Box::new(ty), array_cap.map(Box::new)),
                span: (sloc..end),
                node_id: ctxt.make_node_id()
            };
        }
        ast::Stmt {
            kind: ast::StmtKind::Local(pat, Some(Box::new(ty)), init.map(|e| Box::new(e))),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
};

SimpleTypeExpr: ast::TypeExpr = {
    <sloc:@L> <name:Name> <generic_args:("::" "<" <OneOrMore<GenericArgument, ",">> ">")?> <eloc:@R> => {
        if let Some(generic_args) = generic_args {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Generic(name, generic_args),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        }
        ast::TypeExpr {
            kind: ast::TypeExprKind::Name(name),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "*" <ty:TypeExpr> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Ref(Box::new(ty)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
};

IfStatement: ast::Stmt = {
    <sloc:@L> "if" <condition:Expression> "{" <bif:Statement*> "}"
    <else_block:("else" <ContinuedIfBlock>)?> <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::If(Box::new(condition), bif, else_block.map(Box::new)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

ContinuedIfBlock: ast::Stmt = {
    <sloc:@L> "{" <body:Statement*> "}" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::Block(body),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sif:IfStatement> => sif
};

WhileStatement: ast::Stmt = {
    <sloc:@L> "while" <condition:Expression> "{" <body:Statement*> "}" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::While(Box::new(condition), body),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ForStatement: ast::Stmt = {
    <sloc:@L> "for" <pat:Pat> "in" <iterator:Expression> "{" <body:Statement*> "}" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::For(pat, Box::new(iterator), body),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ControlFlowStmt: ast::Stmt = {
    <sloc:@L> "break" ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::ControlFlow(ast::ControlFlow::Break),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "continue" ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::ControlFlow(ast::ControlFlow::Continue),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ExpressionStmt: ast::Stmt = {
    <sloc:@L> <expr:Expression> <assign:AssignSuffix?> ";" <eloc:@R> => {
        if let Some(assign) = assign {
            return ast::Stmt {
                kind: ast::StmtKind::Assign(Box::new(expr), Box::new(assign)),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        }
        ast::Stmt {
            kind: ast::StmtKind::Expr(Box::new(expr)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

AssignSuffix: ast::Expr = {
    "=" <expr:Expression> => expr,
};

ReturnStmt: ast::Stmt = {
    <sloc:@L> "return" <expr:Expression?> ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::Return(expr.map(|e| Box::new(e))),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

#[inline]
Expression: ast::Expr = {
    RangeExpr,
};

RangeExpr: ast::Expr = {
    <sloc:@L> <lhs:OrExpr> ".." <inclusive:"="?> <rhs:OrExpr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Range(
            Box::new(lhs), Box::new(rhs), inclusive.is_some()),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    OrExpr 
};

OrExpr: ast::Expr = {
    <mut exprs:(<AndExpr> "||")+> <end:AndExpr> <eloc:@R> => {
        exprs.push(end);
        ast::binop_exprs2expr(exprs, ast::BinaryOperator::BooleanOr, eloc)
    },
    AndExpr,
};

AndExpr: ast::Expr = {
    <mut exprs:(<NotExpr> "&&")+> <end:NotExpr> <eloc:@R> => {
        exprs.push(end);
        ast::binop_exprs2expr(exprs, ast::BinaryOperator::BooleanAnd, eloc)
    },
    NotExpr
};

NotExpr: ast::Expr = {
    <sloc:@L> "!" <expr:NotExpr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::UnaryOp(Box::new(expr), ast::UnaryOperator::BooleanNot),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    ComparisonExpr
};

ComparisonExpr: ast::Expr = {
    <sloc:@L> <lhs:BitwiseOr> <op:ComparisonOp> <rhs:BitwiseOr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    BitwiseOr
};

ComparisonOp: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::Equal,
    "!=" => ast::BinaryOperator::NotEqual,
    ">" => ast::BinaryOperator::GreaterThan,
    ">=" => ast::BinaryOperator::GreaterEqual,
    "<" => ast::BinaryOperator::LessThan,
    "<=" => ast::BinaryOperator::LessEqual
};

BitwiseOr: ast::Expr = {
    <sloc:@L> <lhs:BitwiseOr> "|" <rhs:BitwiseXor> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseOr })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    BitwiseXor 
};

BitwiseXor: ast::Expr = {
    <sloc:@L> <lhs:BitwiseXor> "^" <rhs:BitwiseAnd> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseXor })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    BitwiseAnd 
};

BitwiseAnd: ast::Expr = {
    <sloc:@L> <lhs:BitwiseAnd> "&" <rhs:ShiftExpr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseAnd })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    ShiftExpr 
};

ShiftExpr: ast::Expr = {
    <sloc:@L> <lhs:ShiftExpr> <op:ShiftOp> <rhs:Math1Expr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    Math1Expr 
};

ShiftOp: ast::BinaryOperator = {
    "<<" => ast::BinaryOperator::ShiftLeft,
    ">>" => ast::BinaryOperator::ShiftRight,
};

Math1Expr: ast::Expr = {
    <sloc:@L> <lhs:Math1Expr> <op:Math1Op> <rhs:Math2Expr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    Math2Expr
};

Math1Op: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
};

Math2Expr: ast::Expr = {
    <sloc:@L> <lhs:Math2Expr> <op:Math2Op> <rhs:UnaryExpr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    UnaryExpr
};

Math2Op: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Mul,
    "/" => ast::BinaryOperator::Div,
    "%" => ast::BinaryOperator::Mod,
};

UnaryExpr: ast::Expr = {
    <sloc:@L> <op:UnaryOp> <expr:UnaryExpr> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::UnaryOp(Box::new(expr), op),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    AtomExpr,
};

UnaryOp: ast::UnaryOperator = {
    "~" => ast::UnaryOperator::BitwiseInvert,
    "-" => ast::UnaryOperator::Neg,
    "+" => ast::UnaryOperator::Pos,
    "&" => ast::UnaryOperator::Ref,
};

AtomExpr: ast::Expr = {
    Atom,
    <sloc:@L> <base:AtomExpr> "[" <args:OneOrMore<Expression, ",">> "]" <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Subscript(Box::new(base), args),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <base:AtomExpr> "." <name:Ident> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Attribute(Box::new(base), name),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

StructFieldInit: ast::FieldInit = {
    <field:Ident> "=" <init:Expression> => 
        ast::FieldInit { field, init: Box::new(init) }
};

FnArgument: ast::FunctionArgument = {
    <value:Expression> =>
        ast::FunctionArgument::Direct(Box::new(value)),
    "out" "var" <pat:Pat> =>
        ast::FunctionArgument::OutVar(pat),
    <arg:Ident> ":" <value:Expression> =>
        ast::FunctionArgument::Keyword(arg, Box::new(value))
};

Atom: ast::Expr = {
    <sloc:@L> <cnst:Constant> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Constant(cnst),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <str:string> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::String(str),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <name:Name> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Name(name),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "(" <items:OneOrMore<Expression, ",">?> ")" 
    <expr_call:("(" <@L> <OneOrMore<FnArgument, ",">?> <@R> ")")?> <eloc:@R> => {
        let mut items = items.unwrap_or(Vec::new());
        if items.len() == 1 {
            return items.pop().unwrap();
        }
        let mut expr = ast::Expr {
            kind: ast::ExprKind::Tuple(items),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        };

        if let Some((start, args, end)) = expr_call {
            expr = ast::Expr {
                kind: ast::ExprKind::FunctionCall(Box::new(expr), args.unwrap_or(Vec::new()), vec![]),
                span: (start..end),
                node_id: ctxt.make_node_id()
            };
        };

        expr
    },
    <sloc:@L> <name:Name> <generic_args:("::" "<" <OneOrMore<GenericArgument, ",">> ">")?>
    "(" <args:OneOrMore<FnArgument, ",">?> ")" <eloc:@R> => {
        let ident = match &name {
            ast::QName::Unresolved(ident) => ident,
            ast::QName::Resolved { ident, .. } => ident,
        };
        let f = ast::Expr {
            span: ident.span.clone(),
            kind: ast::ExprKind::Name(name),
            node_id: ctxt.make_node_id()
        };
        ast::Expr {
            kind: ast::ExprKind::FunctionCall(
                Box::new(f), args.unwrap_or(Vec::new()), generic_args.unwrap_or(Vec::new())),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "." <variant:Ident> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::ShorthandEnum(variant),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

Constant: ast::Constant = {
    "true" => ast::Constant::Boolean(true),
    "false" => ast::Constant::Boolean(false),
    "None" => ast::Constant::None,
    <i:integer> => ast::Constant::Integer(i),
};

TypeExpr: ast::TypeExpr = {
    <sloc:@L> <is_closure:IsClosure> "(" <params: OneOrMore<TypeExpr, ",">?> ")"
    <rty:("->" <TypeExpr>)?> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Function {
                param_tys: params.unwrap_or(Vec::new()),
                return_ty: rty.map(Box::new),
                is_closure
            },
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "*" <ty:TypeExpr> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Ref(Box::new(ty)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> <name:Name> <generic_args:("<" <OneOrMore<GenericArgument, ",">> ">")?> <eloc:@R> => {
        if let Some(generic_args) = generic_args {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Generic(name, generic_args),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        }
        ast::TypeExpr {
            kind: ast::TypeExprKind::Name(name),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "[" <cap:ArrayCap> "]" <base:TypeExpr> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Array(Box::new(base), cap.map(Box::new)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

ArrayCap: Option<ast::Expr> = {
    "..." => None,
    <expr:Expression> => Some(expr),
};

IsClosure: bool = {
    "fn" => false,
    "closure" => true
};

GenericArgument: ast::GenericArgument = {
    <ty:TypeExpr> => ast::GenericArgument::Ty(ty),
    <c:Constant> => ast::GenericArgument::Constant(c)
};

GenericParams: Vec<ast::GenericParam> = {
    OneOrMore<GenericParam, ",">
};

GenericParam: ast::GenericParam = {
    <sloc:@L> <ident:Ident> <re:("/" <OneOrMore<TypeExpr, "&">>)?> <eloc:@R> => ast::GenericParam {
        ident,
        kind: ast::GenericParamKind::Type(re.unwrap_or(Vec::new())),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

PatLit: ast::Expr = {
    <sloc:@L> <cnst:Constant> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Constant(cnst),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <str:string> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::String(str),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

Pat: ast::Pattern = {
    <ident:Ident> => ast::Pattern {
        span: ident.span.clone(),
        kind: ast::PatternKind::Ident(ident),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "(" <items:SeperatedList<Pat, ",">> ")" <eloc:@R> => ast::Pattern {
        kind: ast::PatternKind::Tuple(items),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <lit:PatLit> <eloc:@R> => ast::Pattern {
        kind: ast::PatternKind::Literal(Box::new(lit)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

Name: ast::QName = {
    <name:Ident> => ast::QName::Unresolved(name)
};

Ident: ast::Ident = {
    <sloc:@L> <s:name> <eloc:@R> => ast::Ident {
        symbol: Symbol::intern(&s),
        span: (sloc..eloc)
    }
};

OneOrMore<T, Sep>: Vec<T> = {
    <e:T> => vec![e],
    <mut v: OneOrMore<T, Sep>> (Sep) <e:T> => {
        v.push(e);
        v
    }
};

SeperatedList<T, Sep>: Vec<T> = {
    <mut v: OneOrMore<T, Sep>> (Sep) <e:T> => {
        v.push(e);
        v
    }
};

extern {
    type Location = usize;
    type Error = ast::UserError;

    enum lexer::TokenKind {
        "." => lexer::TokenKind::Dot,
        "," => lexer::TokenKind::Comma,
        ":" => lexer::TokenKind::Colon,
        "::" => lexer::TokenKind::DoubleColon,
        ";" => lexer::TokenKind::Semicolon,
        "[" => lexer::TokenKind::LBracket,
        "]" => lexer::TokenKind::RBracket,
        "{" => lexer::TokenKind::LCurly,
        "}" => lexer::TokenKind::RCurly,
        "(" => lexer::TokenKind::LParen,
        ")" => lexer::TokenKind::RParen,
        "=" => lexer::TokenKind::Assign,
        ".." => lexer::TokenKind::DotDot,
        "..." => lexer::TokenKind::DotDotDot,
        "->" => lexer::TokenKind::Arrow,
        "$" => lexer::TokenKind::Dollar,
        "@" => lexer::TokenKind::At,

        "&" => lexer::TokenKind::Ampersand,
        "|" => lexer::TokenKind::VBar,
        "^" => lexer::TokenKind::Circumflex,
        "~" => lexer::TokenKind::Tilde,

        "+" => lexer::TokenKind::Plus,
        "-" => lexer::TokenKind::Minus,
        "*" => lexer::TokenKind::Star,
        "/" => lexer::TokenKind::Slash,
        "%" => lexer::TokenKind::Percent,

        "<<" => lexer::TokenKind::LDoubleChevron,
        ">>" => lexer::TokenKind::RDoubleChevron,

        "<" => lexer::TokenKind::LChevron,
        "<=" => lexer::TokenKind::LChevronEq,
        ">" => lexer::TokenKind::RChevron,
        ">=" => lexer::TokenKind::RChevronEq,
        "==" => lexer::TokenKind::DoubleEq,
        "!=" => lexer::TokenKind::BangEq,

        "||" => lexer::TokenKind::DoubleVBar,
        "&&" => lexer::TokenKind::DoubleAmpersand,
        "!" => lexer::TokenKind::Bang,

        "const" => lexer::TokenKind::Const,
        "use" => lexer::TokenKind::Use,
        "with" => lexer::TokenKind::With,
        "unit" => lexer::TokenKind::Unit,
        "var" => lexer::TokenKind::Var,
        "static" => lexer::TokenKind::Static,
        "as" => lexer::TokenKind::As,
        "out" => lexer::TokenKind::Out,
        "is" => lexer::TokenKind::Is,
        "extern" => lexer::TokenKind::Extern,
        "fn" => lexer::TokenKind::Fn,
        "while" => lexer::TokenKind::While,
        "for" => lexer::TokenKind::For,
        "in" => lexer::TokenKind::In,
        "if" => lexer::TokenKind::If,
        "else" => lexer::TokenKind::Else,
        "struct" => lexer::TokenKind::Struct,
        "return" => lexer::TokenKind::Return,
        "break" => lexer::TokenKind::Break,
        "continue" => lexer::TokenKind::Continue,
        "closure" => lexer::TokenKind::Closure,

        "true" => lexer::TokenKind::True,
        "false" => lexer::TokenKind::False,
        "None" => lexer::TokenKind::None,

        name => lexer::TokenKind::Name(<String>),
        string => lexer::TokenKind::String(<String>),
        integer => lexer::TokenKind::Intnumber(<u64>),
    }
}

