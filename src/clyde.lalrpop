use crate::{
    ast, lexer,
    symbol::Symbol, 
    parser::ParseContext as Context,
};

grammar<'a, 'tcx>(ctxt: &'a mut Context<'tcx>);

pub SourceFile: ast::SourceFile = {
    <start:@L> <items:Items> <end:@R> => ast::SourceFile {
        items,
        span: (start..end),
        node_id: ctxt.make_node_id(),
    }
};

Items: Vec<ast::Item> = {
    => vec![],
    <mut items:Items> <next:Item> => {
        items.push(next);
        items
    }
};

Item: ast::Item = {
    GlobalDef,
    StructDef,
    EnumDef,
    FunctionDef,
};

GlobalDef: ast::Item = {
    <sloc:@L> <is_const:"const"?> <ty:TypeExpr> <ident:Ident> <init:("=" <Expression<"all">>)?> ";" <eloc:@R> => ast::Item {
        ident,
        kind: ast::ItemKind::GlobalVar(Box::new(ty), init.map(|b| Box::new(b)), is_const.is_some()),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

StructDef: ast::Item = {
    <sloc:@L> "struct" <ident:Ident> <generics:("<" <GenericParams> ">")?> "{" <f:StructField*> "}" <eloc:@R> => {
        let stc = ast::Struct {
            generics: generics.unwrap_or(Vec::new()),
            fields: f,
            attributes: vec![]
        };
        ast::Item {
            ident,
            kind: ast::ItemKind::Struct(stc),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

StructField: ast::FieldDef = {
    <sloc:@L> <ty:TypeExpr> <name:Ident> <default_init:("=" <Expression<"all">>)?> ";" <eloc:@R> => ast::FieldDef {
        name,
        ty,
        default_init: default_init.map(Box::new),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id(),
        def_id: ast::DEF_ID_UNDEF
    }
};

EnumDef: ast::Item = {
    <sloc:@L> "enum" <ident:Ident> <extends:(":" <TypeExpr>)?> "{" <v:OneOrMore<VariantDef, ",">> "}" <eloc:@R> => {
        let en = ast::Enum {
            extends: extends.map(Box::new),
            variants: v,
            attributes: vec![]
        };
        ast::Item {
            ident,
            kind: ast::ItemKind::Enum(en),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

VariantDef: ast::VariantDef = {
    <sloc:@L> <name:Ident> <sset:("=" <Expression<"all">>)?> <eloc:@R> => ast::VariantDef {
        name, sset: sset.map(Box::new), span: (sloc..eloc), node_id: ctxt.make_node_id(),
    }
};

FunctionDef: ast::Item = {
    <sloc:@L> <ret_ty:TypeExpr> <ident:Ident> <generics:("<" <GenericParams> ">")?> 
    <p:Parameters> <body:Body> <eloc:@R> => {
        let sig = ast::FnSignature {
            params: p.unwrap_or(Vec::new()),
            returns: ret_ty,
            generics: generics.unwrap_or(Vec::new()),
        };
        let func = ast::Function {
            sig,
            span: (sloc..eloc),
            body,
            attributes: vec![]
        };
        ast::Item {
            ident,
            kind: ast::ItemKind::Function(Box::new(func)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
};

Body: Option<Box<ast::Expr>> = {
    <sloc:@L> "{" <stmts:Statement*> "}" <eloc:@R> => Some(Box::new(ast::Expr { 
        kind: ast::ExprKind::Block(stmts),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    })),
    ";" => None,
};

Parameters: Option<Vec<ast::Param>> = {
    "(" <p:OneOrMore<Paramter, ",">?> ")" => p
};

Paramter: ast::Param = {
    <sloc:@L> <ty:TypeExpr> <ident:Ident> <eloc:@R>  => {
        ast::Param {
            ident,
            ty,
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

Statement: ast::Stmt = {
    LocalStatement,
    IfStatement,
    WhileStatement,
    ForStatement,
    ControlFlowStmt,
    ExpressionStmt,
    ReturnStmt,
    ! =>? ast::handle_stmt_error(<>, ctxt.diagnostics)
};

LocalStatement: ast::Stmt = {
    <sloc:@L> "var" <ident:Ident> <init:("=" <Expression<"all">>)?> ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::Local(ident, None, init.map(|e| Box::new(e))),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <ty:SimpleTypeExpr> <name:Ident> <init:("=" <Expression<"all">>)?> ";" <eloc:@R> => {
        ast::Stmt {
            kind: ast::StmtKind::Local(name, Some(Box::new(ty)), init.map(|e| Box::new(e))),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
};

SimpleTypeExpr: ast::TypeExpr = {
    <sloc:@L> <name:Name> <generic_args:("::" <@L> "<"  <OneOrMore<GenericArgument, ",">> ">" <@R>)?> <eloc:@R> => {
        if let Some((start, generic_args, end)) = generic_args {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Generic(name, generic_args),
                span: (start..end),
                node_id: ctxt.make_node_id()
            };
        }
        ast::TypeExpr {
            kind: ast::TypeExprKind::Name(name),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "*" <ty:TypeExpr> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Ref(Box::new(ty)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "[" <cap:ArrayCap?> "]" <base:TypeExpr> <eloc:@R> => {
        let Some(cap) = cap else {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Slice(Box::new(base)),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        };
        ast::TypeExpr {
            kind: ast::TypeExprKind::Array(Box::new(base), cap),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

IfStatement: ast::Stmt = {
    <sloc:@L> "if" <condition:Expression<"no-blocks">> "{" <bif:Statement*> "}"
    <else_block:("else" <ContinuedIfBlock>)?> <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::If(Box::new(condition), bif, else_block.map(Box::new)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

ContinuedIfBlock: ast::Stmt = {
    <sloc:@L> "{" <body:Statement*> "}" <eloc:@R> => {
        let body = ast::Expr {
            kind: ast::ExprKind::Block(body),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        };
        ast::Stmt {
            kind: ast::StmtKind::Expr(Box::new(body)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sif:IfStatement> => sif
};

WhileStatement: ast::Stmt = {
    <sloc:@L> "while" <condition:Expression<"no-blocks">> "{" <body:Statement*> "}" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::While(Box::new(condition), body),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ForStatement: ast::Stmt = {
    <sloc:@L> "for" <ident:Ident> "in" <iterator:Expression<"no-blocks">> "{" <body:Statement*> "}" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::For(ident, Box::new(iterator), body),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ControlFlowStmt: ast::Stmt = {
    <sloc:@L> "break" ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::ControlFlow(ast::ControlFlow::new(ast::ControlFlowKind::Break)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "continue" ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::ControlFlow(ast::ControlFlow::new(ast::ControlFlowKind::Continue)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

ExpressionStmt: ast::Stmt = {
    <sloc:@L> <expr:Expression<"all">> <assign:AssignSuffix?> ";" <eloc:@R> => {
        if let Some(assign) = assign {
            return ast::Stmt {
                kind: ast::StmtKind::Assign(Box::new(expr), Box::new(assign)),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        }
        ast::Stmt {
            kind: ast::StmtKind::Expr(Box::new(expr)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

AssignSuffix: ast::Expr = {
    "=" <expr:Expression<"all">> => expr,
};

ReturnStmt: ast::Stmt = {
    <sloc:@L> "return" <expr:Expression<"all">?> ";" <eloc:@R> => ast::Stmt {
        kind: ast::StmtKind::Return(expr.map(|e| Box::new(e))),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

#[inline]
Expression<What>: ast::Expr = {
    RangeExpr<What>
};

RangeExpr<What>: ast::Expr = {
    <sloc:@L> <lhs:OrExpr<What>> ".." <inclusive:"="?> <rhs:OrExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Range(
            Box::new(lhs), Box::new(rhs), inclusive.is_some()),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    OrExpr<What>
};

OrExpr<What>: ast::Expr = {
    <sloc:@L> <lhs:OrExpr<What>> "||" <rhs:AndExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BooleanOr })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    AndExpr<What>
};

AndExpr<What>: ast::Expr = {
    <sloc:@L> <lhs:AndExpr<What>> "&&" <rhs:NotExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BooleanAnd })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    NotExpr<What>
};

NotExpr<What>: ast::Expr = {
    <sloc:@L> "!" <expr:NotExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::UnaryOp(Box::new(expr), ast::UnaryOperator::BooleanNot),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    ComparisonExpr<What>
};

ComparisonExpr<What>: ast::Expr = {
    <sloc:@L> <lhs:BitwiseOr<What>> <op:ComparisonOp> <rhs:BitwiseOr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    BitwiseOr<What>
};

ComparisonOp: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::Equal,
    "!=" => ast::BinaryOperator::NotEqual,
    ">" => ast::BinaryOperator::GreaterThan,
    ">=" => ast::BinaryOperator::GreaterEqual,
    "<" => ast::BinaryOperator::LessThan,
    "<=" => ast::BinaryOperator::LessEqual
};

BitwiseOr<What>: ast::Expr = {
    <sloc:@L> <lhs:BitwiseOr<What>> "|" <rhs:BitwiseXor<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseOr })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    BitwiseXor<What>
};

BitwiseXor<What>: ast::Expr = {
    <sloc:@L> <lhs:BitwiseXor<What>> "^" <rhs:BitwiseAnd<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseXor })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    BitwiseAnd<What>
};

BitwiseAnd<What>: ast::Expr = {
    <sloc:@L> <lhs:BitwiseAnd<What>> "&" <rhs:ShiftExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: ast::BinaryOperator::BitwiseAnd })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    ShiftExpr<What>
};

ShiftExpr<What>: ast::Expr = {
    <sloc:@L> <lhs:ShiftExpr<What>> <op:ShiftOp> <rhs:Math1Expr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }, 
    Math1Expr<What>
};

ShiftOp: ast::BinaryOperator = {
    "<<" => ast::BinaryOperator::ShiftLeft,
    ">>" => ast::BinaryOperator::ShiftRight,
};

Math1Expr<What>: ast::Expr = {
    <sloc:@L> <lhs:Math1Expr<What>> <op:Math1Op> <rhs:Math2Expr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    Math2Expr<What>
};

Math1Op: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Plus,
    "-" => ast::BinaryOperator::Minus,
};

Math2Expr<What>: ast::Expr = {
    <sloc:@L> <lhs:Math2Expr<What>> <op:Math2Op> <rhs:DerefExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::BinOp(
            Box::new(ast::BinOp { lhs, rhs, operator: op })),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    DerefExpr<What>, 
};

Math2Op: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Mul,
    "/" => ast::BinaryOperator::Div,
    "%" => ast::BinaryOperator::Mod,
};

DerefExpr<What>: ast::Expr = {
    <sloc:@L> "^" <expr:DerefExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Deref(Box::new(expr)),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    CastExpr<What>,
};

CastExpr<What>: ast::Expr = {
    <sloc:@L> <tc:CastOrPun> "(" <autoty:TypeOrAuto> ")" <expr:CastExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Cast(Box::new(expr), autoty.map(Box::new), tc),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    UnaryExpr<What>,
};

TypeOrAuto: Option<ast::TypeExpr> = {
    "?" => None,
    <ty:TypeExpr> => Some(ty),
};

CastOrPun: ast::TypeConversion = {
    "cast" => ast::TypeConversion::Cast,
    "pun" => ast::TypeConversion::Transmute
};

UnaryExpr<What>: ast::Expr = {
    <sloc:@L> <op:UnaryOp> <expr:UnaryExpr<What>> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::UnaryOp(Box::new(expr), op),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    AtomExpr<What>,
};

UnaryOp: ast::UnaryOperator = {
    "~" => ast::UnaryOperator::BitwiseInvert,
    "-" => ast::UnaryOperator::Neg,
    "&" => ast::UnaryOperator::Ref,
};

AtomExpr<What>: ast::Expr = {
    Atom<What>,
    <sloc:@L> <base:AtomExpr<What>> "[" <args:OneOrMore<Expression<"all">, ",">> "]" <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Subscript(Box::new(base), args),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <base:AtomExpr<What>> "." <name:Ident> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Field(Box::new(base), name),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

FnArgument: ast::FunctionArgument = {
    <value:Expression<"all">> =>
        ast::FunctionArgument::Direct(Box::new(value)),
    <arg:Ident> ":" <value:Expression<"all">> =>
        ast::FunctionArgument::Keyword(arg, Box::new(value))
};

Atom<What>: ast::Expr = {
    <sloc:@L> <cnst:Constant> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Constant(cnst),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <str:string> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::String(str),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <name:Name> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Name(name),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "(" <items:OneOrMore<Expression<"all">, ",">?> ")" 
    <expr_call:("(" <@L> <OneOrMore<FnArgument, ",">?> <@R> ")")?> <eloc:@R> => {
        let mut items = items.unwrap_or(Vec::new());
        if items.len() == 1 {
            return items.pop().unwrap();
        }
        let mut expr = ast::Expr {
            kind: ast::ExprKind::Tuple(items),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        };

        if let Some((start, args, end)) = expr_call {
            expr = ast::Expr {
                kind: ast::ExprKind::FunctionCall(Box::new(expr), args.unwrap_or(Vec::new()), vec![]),
                span: (start..end),
                node_id: ctxt.make_node_id()
            };
        };

        expr
    },
    <sloc:@L> <name:Name> <generic_args:("::" "<" <OneOrMore<GenericArgument, ",">> ">")?>
    "(" <args:OneOrMore<FnArgument, ",">?> ")" <eloc:@R> => {
        let ident = match &name {
            ast::QName::Unresolved(ident) => ident,
            ast::QName::Resolved { ident, .. } => ident,
        };
        let f = ast::Expr {
            span: ident.span.clone(),
            kind: ast::ExprKind::Name(name),
            node_id: ctxt.make_node_id()
        };
        ast::Expr {
            kind: ast::ExprKind::FunctionCall(
                Box::new(f), args.unwrap_or(Vec::new()), generic_args.unwrap_or(Vec::new())),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "." <variant:Ident> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::ShorthandEnum(variant),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <tyi:TypeOrArrayInit> "{" <inits:OneOrMore<FieldOrDirectInit, ",">?> "}" <eloc:@R> if What != "no-blocks" => ast::Expr {
        kind: ast::ExprKind::TypeInit(tyi.map(Box::new), inits.unwrap_or(Vec::new())),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "{" <stmts:Statement*> "}" <eloc:@R> if What != "no-blocks" => ast::Expr { 
        kind: ast::ExprKind::Block(stmts),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

TypeOrArrayInit: Option<ast::TypeExpr> = {
    <sloc:@L> <name:Name> <generic_args:("::" <@L> "<"  <OneOrMore<GenericArgument, ",">> ">" <@R>)?> <eloc:@R> => {
        if let Some((start, generic_args, end)) = generic_args {
            return Some(ast::TypeExpr {
                kind: ast::TypeExprKind::Generic(name, generic_args),
                span: (start..end),
                node_id: ctxt.make_node_id()
            });
        }
        Some(ast::TypeExpr {
            kind: ast::TypeExprKind::Name(name),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        })
    },
    <sloc:@L> "[" <cap:ArrayCap?> "]" <base:TypeExpr> <eloc:@R> => {
        let Some(cap) = cap else {
            return Some(ast::TypeExpr {
                kind: ast::TypeExprKind::Slice(Box::new(base)),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            });
        };
        Some(ast::TypeExpr {
            kind: ast::TypeExprKind::Array(Box::new(base), cap),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        })
    },
    "?" => None
};

FieldOrDirectInit: ast::TypeInit = {
    <field:Ident> "=" <init:Expression<"all">> => 
        ast::TypeInit::Field(field, Box::new(init)),
    <init:Expression<"all">> => 
        ast::TypeInit::Direct(Box::new(init))
};

Constant: ast::Constant = {
    "true" => ast::Constant::Boolean(true),
    "false" => ast::Constant::Boolean(false),
    "null" => ast::Constant::Null,
    <i:integer> => ast::Constant::Integer(i),
    <c:char> => ast::Constant::Char(c),
};

TypeExpr: ast::TypeExpr = {
    <sloc:@L> <is_closure:IsClosure> "(" <params: OneOrMore<TypeExpr, ",">?> ")"
    <rty:("->" <TypeExpr>)?> <eloc:@R> => todo!(),
    <sloc:@L> "*" <ty:TypeExpr> <eloc:@R> => {
        ast::TypeExpr {
            kind: ast::TypeExprKind::Ref(Box::new(ty)),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> <name:Name> <generic_args:("<" <OneOrMore<GenericArgument, ",">> ">")?> <eloc:@R> => {
        if let Some(generic_args) = generic_args {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Generic(name, generic_args),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        }
        ast::TypeExpr {
            kind: ast::TypeExprKind::Name(name),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    },
    <sloc:@L> "[" <cap:ArrayCap?> "]" <base:TypeExpr> <eloc:@R> => {
        let Some(cap) = cap else {
            return ast::TypeExpr {
                kind: ast::TypeExprKind::Slice(Box::new(base)),
                span: (sloc..eloc),
                node_id: ctxt.make_node_id()
            };
        };
        ast::TypeExpr {
            kind: ast::TypeExprKind::Array(Box::new(base), cap),
            span: (sloc..eloc),
            node_id: ctxt.make_node_id()
        }
    }
};

ArrayCap: ast::ArrayCapacity = {
    "?" => ast::ArrayCapacity::Infer,
    ".." => ast::ArrayCapacity::Dynamic,
    <expr:Expression<"all">> => ast::ArrayCapacity::Discrete(Box::new(expr)),
};

IsClosure: bool = {
    "fn" => false,
    "closure" => true
};

GenericArgument: ast::GenericArgument = {
    <ty:TypeExpr> => ast::GenericArgument::Ty(ty),
    <c:Constant> => ast::GenericArgument::Constant(c)
};

GenericParams: Vec<ast::GenericParam> = {
    OneOrMore<GenericParam, ",">
};

GenericParam: ast::GenericParam = {
    <sloc:@L> <ident:Ident> <eloc:@R> => ast::GenericParam {
        ident,
        kind: ast::GenericParamKind::Type(vec![]),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> "const" <ty:TypeExpr> <ident:Ident> <eloc:@R> => ast::GenericParam {
        ident,
        kind: ast::GenericParamKind::Const(ty),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    }
};

PatLit: ast::Expr = {
    <sloc:@L> <cnst:Constant> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::Constant(cnst),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
    <sloc:@L> <str:string> <eloc:@R> => ast::Expr {
        kind: ast::ExprKind::String(str),
        span: (sloc..eloc),
        node_id: ctxt.make_node_id()
    },
};

Name: ast::QName = {
    <name:Ident> => ast::QName::Unresolved(name)
};

Ident: ast::Ident = {
    <sloc:@L> <s:name> <eloc:@R> => ast::Ident {
        symbol: Symbol::intern(&s),
        span: (sloc..eloc)
    }
};

OneOrMore<T, Sep>: Vec<T> = {
    <e:T> => vec![e],
    <mut v: OneOrMore<T, Sep>> (Sep) <e:T> => {
        v.push(e);
        v
    }
};

SeperatedList<T, Sep>: Vec<T> = {
    <mut v: OneOrMore<T, Sep>> (Sep) <e:T> => {
        v.push(e);
        v
    }
};

extern {
    type Location = usize;
    type Error = ast::UserError;

    enum lexer::TokenKind {
        "." => lexer::TokenKind::Dot,
        "," => lexer::TokenKind::Comma,
        ":" => lexer::TokenKind::Colon,
        "::" => lexer::TokenKind::DoubleColon,
        ";" => lexer::TokenKind::Semicolon,
        "[" => lexer::TokenKind::LBracket,
        "]" => lexer::TokenKind::RBracket,
        "{" => lexer::TokenKind::LCurly,
        "}" => lexer::TokenKind::RCurly,
        "(" => lexer::TokenKind::LParen,
        ")" => lexer::TokenKind::RParen,
        "=" => lexer::TokenKind::Assign,
        ".." => lexer::TokenKind::DotDot,
        "->" => lexer::TokenKind::Arrow,
        "^" => lexer::TokenKind::Circumflex,
        "?" => lexer::TokenKind::Question,

        "&" => lexer::TokenKind::Ampersand,
        "|" => lexer::TokenKind::VBar,
        "^" => lexer::TokenKind::Circumflex,
        "~" => lexer::TokenKind::Tilde,

        "+" => lexer::TokenKind::Plus,
        "-" => lexer::TokenKind::Minus,
        "*" => lexer::TokenKind::Star,
        "/" => lexer::TokenKind::Slash,
        "%" => lexer::TokenKind::Percent,

        "<<" => lexer::TokenKind::LDoubleChevron,
        ">>" => lexer::TokenKind::RDoubleChevron,

        "<" => lexer::TokenKind::LChevron,
        "<=" => lexer::TokenKind::LChevronEq,
        ">" => lexer::TokenKind::RChevron,
        ">=" => lexer::TokenKind::RChevronEq,
        "==" => lexer::TokenKind::DoubleEq,
        "!=" => lexer::TokenKind::BangEq,

        "||" => lexer::TokenKind::DoubleVBar,
        "&&" => lexer::TokenKind::DoubleAmpersand,
        "!" => lexer::TokenKind::Bang,

        "const" => lexer::TokenKind::Const,
        "use" => lexer::TokenKind::Use,
        "with" => lexer::TokenKind::With,
        "unit" => lexer::TokenKind::Unit,
        "var" => lexer::TokenKind::Var,
        "static" => lexer::TokenKind::Static,
        "cast" => lexer::TokenKind::Cast,
        "pun" => lexer::TokenKind::Pun,
        "out" => lexer::TokenKind::Out,
        "is" => lexer::TokenKind::Is,
        "extern" => lexer::TokenKind::Extern,
        "fn" => lexer::TokenKind::Fn,
        "while" => lexer::TokenKind::While,
        "for" => lexer::TokenKind::For,
        "in" => lexer::TokenKind::In,
        "if" => lexer::TokenKind::If,
        "else" => lexer::TokenKind::Else,
        "struct" => lexer::TokenKind::Struct,
        "enum" => lexer::TokenKind::Enum,
        "return" => lexer::TokenKind::Return,
        "break" => lexer::TokenKind::Break,
        "continue" => lexer::TokenKind::Continue,
        "closure" => lexer::TokenKind::Closure,

        "true" => lexer::TokenKind::True,
        "false" => lexer::TokenKind::False,
        "null" => lexer::TokenKind::Null,

        name => lexer::TokenKind::Name(<String>),
        string => lexer::TokenKind::String(<String>),
        integer => lexer::TokenKind::Intnumber(<u64>),
        char => lexer::TokenKind::Char(<char>),
    }
}

